---
title: "R Notebook"
output: html_notebook
---

# Load packages in

```{r}
pacman::p_load(sf, readr, tidyverse, tmap, sf, spNetwork, sfdep)
```

# Load Data in

## Geospatial Data

```{r}
seoul <- st_read(dsn = "data_final/seoul_adm2",
                 layer= "seoul_adm2") %>%
  st_transform(crs = 5179)
```

```{r}
clinics <- st_read(dsn = "data_final/seoul_clinics",
                   layer = "seoul_clinics") %>%
  st_transform(crs = 5179)
hospitals <- st_read(dsn = "data_final/seoul_hospitals",
                     layer = "seoul_hospitals") %>%
  st_transform(crs = 5179)
residence <- st_read(dsn = "data_final/seoul_residential",
                     layer = "seoul_residential") %>%
  st_transform(crs = 5179)
road <- st_read(dsn="data_final/seoul_roads",
                layer = "seoul_roads_v2")%>%
  st_transform(crs = 5179)
```

## Select wanted datasets

```{r}
#clinics <- clinics %>%
#  select(1,3)
#hospitals <- hospitals %>%
#  select(1,3)
#residence <- residence %>%
#  select(1,3)
#road <- road %>%
#  select(1,3)
```

## Aspatial Data

```{r}
population <- read_csv("data_final/population_seoul.csv")
```

# Data Wrangling

## Geospatial

```{r, eval = FALSE}
seoul_pop <- st_read(dsn = "data_final/seoul_pop",
                     layer = "seoul_pop")
```

```{r}
tm_shape(seoul_pop)+
  tm_fill("Eldrly_", 
          style = "quantile", 
          palette = "Greens",
          title = "Elderly Population") +
  tm_layout(main.title = "Elderly Population",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha =0.2) +
  tm_credits("Source: Data.korea", 
             position = c("left", "bottom")) +
  tmap_style("classic")
```

# Start of **Local Colocation Quotients**

### LCLQ of residence locations vs hospitals

Converting polygon data to point data by obtaining their centroids

```{r}
hospitals_point <- st_centroid(hospitals)
```

```{r}
residence_point <- st_centroid(residence)
```

Additional data cleaning to join hospitals and residence data

```{r}
residence_point <- residence_point[,-5]
```

```{r}
hospitals_residence <- rbind(hospitals_point, residence_point)
```

**Preparing nearest neighbours list (assuming k=6)**

```{r}
nb_hospitals <- include_self(
  st_knn(st_geometry(hospitals_residence), 6))
```

**Computing kernel weights**

```{r}
wt_hospitals <- st_kernel_weights(nb_hospitals, 
                        hospitals_residence, 
                        "gaussian", 
                        adaptive = TRUE)
```

**Preparing vector list**

```{r}
hospital <- hospitals_residence %>%
  filter(fclass == "hospital")
A <- hospital$fclass
```

```{r}
residences <- hospitals_residence %>%
  filter(fclass == "building")
B <- residences$fclass
```

**Computing LCLQ, with number of simulations being 49**

```{r}
#| eval: false
LCLQ_hospitals <- local_colocation(A, B, nb_hospitals, wt_hospitals, 49)
```

**Saving output for LCLQ hospitals to residence**

```{r}
write_rds(LCLQ_hospitals, "data_final/model/LCLQ_hospitals.rds")
```

**Bringing in previously computed output**

```{r}
LCLQ_hospitals <- read_rds("data_final/model/LCLQ_hospitals.rds")
```

**Joining output data**

```{r}
hospitals_residence_LCLQ <- cbind(hospitals_residence, LCLQ_hospitals)
```

**Visualising LCLQ values**

```{r}
tmap_mode("view")
tm_shape(seoul) +
  tm_polygons() +
tm_shape(hospitals_residence_LCLQ)+ 
  tm_dots(col = "building",
             size = 0.01,
             border.col = "black",
             border.lwd = 0.5)
```

### LCLQ of residence locations vs clinics

Converting polygon data to point data by obtaining their centroids

```{r}
clinics_point <- st_centroid(clinics)
```

**Combining residence and clinics data**

```{r}
clinics_residence <- rbind(clinics_point, residence_point)
```

**Preparing nearest neighbours list (assuming k=6)**

```{r}
nb_clinics <- include_self(
  st_knn(st_geometry(clinics_residence), 6))
```

**Computing kernel weights**

```{r}
wt_clinics <- st_kernel_weights(nb_clinics, 
                        clinics_residence, 
                        "gaussian", 
                        adaptive = TRUE)
```

**Preparing vector list**

```{r}
clinic <- clinics_residence %>%
  filter(fclass == "clinic")
A <- clinic$fclass
```

```{r}
residences <- clinics_residence %>%
  filter(fclass == "building")
B <- residences$fclass
```

**Computing LCLQ, with number of simulations being 49**

```{r}
#| eval: false
LCLQ_clinics <- local_colocation(A, B, nb_clinics, wt_clinics, 49)
```

**Saving output for LCLQ clinics to residence**

```{r}
write_rds(LCLQ_clinics, "data_final/model/LCLQ_clinics.rds")
```

**Bringing in previously computed outputs**

```{r}
LCLQ_clinics <- read_rds("data_final/model/LCLQ_clinics.rds")
```

**Joining output data**

```{r}
clinics_residence_LCLQ <- cbind(clinics_residence, LCLQ_clinics)
```

**Visualising LCLQ values**

```{r}
tmap_mode("view")
tm_shape(seoul) +
  tm_polygons() +
tm_shape(clinics_residence_LCLQ)+ 
  tm_dots(col = "building",
             size = 0.01,
             border.col = "black",
             border.lwd = 0.5)
```

```{r}
hospitals_residence_LCLQ %>% count(building < 0.99)
```

```{r}
clinics_residence_LCLQ %>% count(building < 0.99)
```

LCLQ values can be used to determine the spatial relationship between the location of clinics and residential buildings. In this case, point-based approach is used. For points marked with the value 1 (in yellow), it indicates that there is a hospital/clinic as a nearest neighbour. In summary, only 2 residential buildings in Seoul does not have adequate access to hospitals and clinics.

LCLQ also adopts distance ranks adaptive bandwidth, and ensures that exactly the same number of points is involved in the estimation of LCLQ at each marked point, returning more robust and reliable results.

References: https://arxiv.org/ftp/arxiv/papers/2006/2006.13277.pdf











